# Modelling eGFR Slope <a href='https://www.georgeinstitute.org'><img src="figs/logo/smartc.png" align="right" height="80" /></a>
 
<!-- badges: start -->
![Languages](https://img.shields.io/badge/Languages-R-6498d3)
![Developed By](https://img.shields.io/badge/Developed%20By-The%20SGLT2%20inhibitor%20Meta--Analysis%20Cardio--Renal%20Trialists%20Consortium-%23129090)
<!-- badges: end -->

## Overview

This repository provides a step-by-step guide to standardised modelling of estimated glomerular filtration rate (eGFR) slope in trials included in the SGLT2 inhibitor Meta-Analysis Cardio-Renal Trialists Consortium (SMART-C). An accompanying reproducible example (reprex) using synthetically-generated data is also provided in the [`code`](https://github.com/ra-fletcher/smartc_egfr_slope/tree/main/code) folder.

A quick note on the reprex: the main objective is to demonstrate how to set-up the data, specify the model, and extract the relevant results for acute, chronic, and total slope. The synthetic data was crudely generated by creating variables that have the same marginal distribution as those in the CREDENCE trial, using the [`simstudy`](https://kgoldfeld.github.io/simstudy/) R library. Creating a synthetic dataset which precisely emulates all variable relationships within longitudinal data is complex, and the main objective of this reprex is to understand the underlying methodology, so the results of the model here won't look congruent with what will be seen with clinical trial data.

If you'd like more information on the statistical methodology for modelling eGFR slope, please see the original publication here: [Vonesh et al., 2019](https://onlinelibrary.wiley.com/doi/10.1002/sim.8282).

## Dependencies

To get this code to work, please install all dependencies. To install theses dependencies (if you haven't already), run the following script:

``` r
libs <- c("glue", "lme4", "multcomp", "simstudy", "tidyverse")

install.packages(setdiff("tidyverse", rownames(installed.packages())))
```

If you have any issues, check your package versions. The following package versions were used for the generation of this code:

``` r
dplyr - v1.1.0
glue - v1.6.2
lme4 - v1.1-31
multcomp - v1.4-20
simstudy - v0.6.0
stringr - v1.5.0
tibble - v3.1.8
tidyr - v1.3.0
```

## Folder structure

Below is an overview of the folders in this repository that are actively synchronised with GitHub.

### code

`code` contains the reprex code: `modelling_egfr_slope_reprex.R` - this reprex will show you how to calculate eGFR slope for the trial overall (treatment, placebo, and comparison) and for two groups in a binary subgroup variable (in this example, glucagon-like peptide-1 receptor agonist (GLP-1RA) use yes/no).

### data

`data` contains synthetic baseline `synthetic_trial_baseline.csv` and follow-up `synthetic_trial_follow_up_egfr.csv` data used in the reprex.

### figs

`figs` contains the logo for the SGLT2 inhibitor Meta-Analysis Cardio-Renal Trialists Consortium (SMART-C) and the CREDENCE eGFR figure used for this README.

### src

`src` contains any files that are called via `source()` in the scripts in `code`. In this instance, the functions used to generate the synthetic data and to extract results from the mixed model.

## Guide

The aim of this repository is to provide a systematic guide to modelling eGFR slope in randomized trials included within SMART-C using R. This guide, enclosed within the repository `README`, will provide a visual guide to:

1. Setting-up the data into the required format
2. Specifying the model
3. Extracting the relevant model results (including acute slope, chronic slope, and total slope)

This guide will demonstrate how to model eGFR slope for the total trial population. If you'd like to know how to apply this code in subgroups, please see the reprex in the [`code`](https://github.com/ra-fletcher/smartc_egfr_slope/tree/main/code) folder.

### Data

The simulated data is for a hypothetical trial of 5000 participants randomised 1:1 to either an SGLT2 inhibitor or placebo (2500 per arm).

Since your trial data will likely be standardised to the [Analysis Data Model (ADaM)](https://www.cdisc.org/standards/foundational/adam), the simulated data has been set-up to imitate a truncated version of the "subject-level analysis dataset" `ADSL`, here termed `baseline` or `bl` and repeat eGFR measurements from the "laboratory - within 2 days of the last meds" dataset `ADLBM`, here termed `follow-up` or `fu`. If you'd like to know what each of the columns in the datasets are, please see the [`README`](https://github.com/ra-fletcher/smartc_egfr_slope/tree/main/data) for the data folder of this repository.

Here is a snapshot of the baseline data:

``` r
# Source function to generate synthetic data
source(glue::glue("{path}/src/generate_synthetic_data.R"))

# Generate synthetic baseline data (derived from ADSL)
bl <- generate_synthetic_data(.table = "baseline")

# Print baseline data
print(bl, n = 10)
#> # A tibble: 5,000 × 8
#>    usubjid trt01pn randfl ittfl trtfl blgfr blglp1 strata                                
#>    <chr>     <int> <chr>  <chr> <chr> <int> <chr>  <chr>                                 
#>  1 id0001        0 Y      Y     Y        54 N      Screening eGFR 45 to <60 mL/min/1.73m2
#>  2 id0002        1 Y      Y     Y        27 N      Screening eGFR 45 to <60 mL/min/1.73m2
#>  3 id0003        1 Y      Y     Y        50 N      Screening eGFR 45 to <60 mL/min/1.73m2
#>  4 id0004        0 Y      Y     Y        47 N      Screening eGFR 45 to <60 mL/min/1.73m2
#>  5 id0005        0 Y      Y     Y        75 N      Screening eGFR 60 to <90 mL/min/1.73m2
#>  6 id0006        0 Y      Y     Y        30 N      Screening eGFR 30 to <45 mL/min/1.73m2
#>  7 id0007        0 Y      Y     Y        56 N      Screening eGFR 45 to <60 mL/min/1.73m2
#>  8 id0008        1 Y      Y     Y        59 N      Screening eGFR 60 to <90 mL/min/1.73m2
#>  9 id0009        1 Y      Y     Y        65 N      Screening eGFR 60 to <90 mL/min/1.73m2
#> 10 id0010        1 Y      Y     Y        70 N      Screening eGFR 60 to <90 mL/min/1.73m2
#> # … with 4,990 more rows
#> # ℹ Use `print(n = ...)` to see more rows
```

Here is a snapshot of the follow-up data:

``` r
# Generate synthetic follow-up data (derived from ADLBM)
fu <- generate_synthetic_data(.table = "follow-up")

# Print follow-up data
print(fu, n = 10)
#> # A tibble: 41,800 × 12
#>    usubjid randfl ittfl trtfl anl01fl  aval  base paramcd  param                                                  ady avisitn avisit  
#>    <chr>   <chr>  <chr> <chr> <chr>   <dbl> <int> <chr>    <chr>                                                <dbl>   <dbl> <chr>   
#>  1 id0001  Y      Y     Y     Y          54    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)     1       0 BASELINE
#>  2 id0001  Y      Y     Y     Y          51    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)    22       3 WEEK 3  
#>  3 id0001  Y      Y     Y     Y          61    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)    91      13 WEEK 13 
#>  4 id0001  Y      Y     Y     Y          63    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)   183      26 WEEK 26 
#>  5 id0001  Y      Y     Y     Y          53    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)   362      52 WEEK 52 
#>  6 id0001  Y      Y     Y     Y          47    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)   544      78 WEEK 78 
#>  7 id0001  Y      Y     Y     Y          37    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)   726     104 WEEK 104
#>  8 id0001  Y      Y     Y     Y          58    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)   911     130 WEEK 130
#>  9 id0001  Y      Y     Y     Y          59    54 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)  1092     156 WEEK 156
#> 10 id0002  Y      Y     Y     Y          27    27 GFRBSCRT GFR from Creatinine Adjusted for BSA (mL/min/1.73m2)     1       0 BASELINE
#> # … with 41,790 more rows
#> # ℹ Use `print(n = ...)` to see more rows
```

The first objective is to define the time point at which to place the knot in the spline fitted to the model. The reason for doing this is because of the acute drop in eGFR that is observed on initiation of an SGLT2 inhibitor. This should correspond to the first follow-up visit in your trial. For instance, in the DAPA-CKD trial ([Heerspink et al., 2020](https://www.nejm.org/doi/full/10.1056/NEJMoa2024816)), this is at 2 weeks (~14 days) post-randomisation, and in the CREDENCE trial ([Perkovic et al., 2019](https://www.nejm.org/doi/full/10.1056/nejmoa1811744)), this is at 3 weeks (~21 days) (see figure below).

<p align="center">
    <img src="figs/guide/credence_egfr.png" width="800" alt>
    <em style="color: green"> The change from the screening level in the estimated GFR in the on-treatment population (Perkovic et al., 2019). </em>
</p>

``` r
# Set knot point for spline. This is 3 weeks/21 days in the CREDENCE trial
k <- 21
```

Next, the data need to be formatted correctly. You will need to specify in the "on-treatment" population in both datasets, and filter for the analysis values in the follow-up eGFR data. You'll also notice that the code generates a "spline term" column. This needs to be set at `0` for times before the knot, and at `time - k / 365.25` for all times after the knot.

The data object `gfr_c` is how you want the data to appear before you commence modelling.

``` r
# Treatment arms (filtering for on-treatment individuals only)
arm <- bl |> 
  dplyr::filter(trtfl == "Y") |> 
  dplyr::select(usubjid, trt01pn, blglp1, strata) |> 
  dplyr::mutate(blglp1 = dplyr::if_else(blglp1 == "Y", 1, 0))

# Repeat eGFR (filtering for on-treatment values and those flagged for analysis)
gfr <- fu |> 
  dplyr::filter(dplyr::if_all(c(trtfl, anl01fl), \(x) x == "Y")) |> 
  dplyr::distinct(usubjid, aval, ady, base, avisitn)

# Join
gfr_c <- arm |> 
  dplyr::left_join(gfr, by = dplyr::join_by(usubjid), multiple = "all") |> 
  dplyr::mutate(
    # Convert days from baseline to years
    time = ady / 365.25,
    # Generate spline term
    spline = dplyr::if_else(time >= k / 365.25, time - k / 365.25, 0)
  )
  
# Print combined data
print(gfr_c, n = 10)
#> # A tibble: 40,957 × 10
#>    usubjid trt01pn blglp1 strata                                  aval   ady  base avisitn    time  spline
#>    <chr>     <int>  <dbl> <chr>                                  <dbl> <dbl> <int>   <dbl>   <dbl>   <dbl>
#>  1 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    54     1    54       0 0.00274 0      
#>  2 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    51    22    54       3 0.0602  0.00274
#>  3 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    61    91    54      13 0.249   0.192  
#>  4 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    63   183    54      26 0.501   0.444  
#>  5 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    53   362    54      52 0.991   0.934  
#>  6 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    47   544    54      78 1.49    1.43   
#>  7 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    37   726    54     104 1.99    1.93   
#>  8 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    58   911    54     130 2.49    2.44   
#>  9 id0001        0      0 Screening eGFR 45 to <60 mL/min/1.73m2    59  1092    54     156 2.99    2.93   
#> 10 id0002        1      0 Screening eGFR 45 to <60 mL/min/1.73m2    27     1    27       0 0.00274 0      
#> # … with 40,947 more rows
#> # ℹ Use `print(n = ...)` to see more rows
```

Here is what each of the columns correspond to:

| Variable  | Type      | Description                                                                   |
| --------- | ----------| ----------------------------------------------------------------------------- |
| `usubjid` | Character | Unique subject identifier                                                     |
| `trt01pn` | Integer   | Numeric indicator for treatment assignment; `0` == "Placebo", `1` == "SGLT2i" |
| `blglp1`  | Double    | Numeric indicator for baseline GLP1-RA use; `0` == "No", `1` == "Yes"         |
| `strata`  | Character | Study strata (not required)                                                   |
| `aval`    | Double    | Estimated glomerular filtration rate (eGFR) value at study visit              |
| `ady`     | Double    | Days from baseline                                                            |
| `base`    | Integer   | Baseline eGFR value                                                           |
| `avisitn` | Double    | Study visit (weeks from baseline; numeric)                                    |
| `time`    | Double    | Years from baseline (`ady` / 365.25)                                          |
| `spline`  | Double    | Spline term                                                                   |

### Model

The model used to calculate eGFR slope is a mixed effects model with an unstructured residual variance-covariance matrix. Typically we would adjust for the stratification term in the trial (categories of screening eGFR in the CREDENCE trial or diabetes status/UACR categories in DAPA-CKD trial), but in the interests of easier-to-implement code, we won't be doing that here. The function required to run the model is `lme4::lmer()`, and the unstructured residual variance-covariance matrix is specified with `(time | usubjid)`. Adding `-1` ensures that no intercept is fitted.

``` r
# Fit mixed effects model with unstructured residual variance-covariance matrix
fit <- lme4::lmer(
  aval ~ base + time * trt01pn + spline * trt01pn - 1 + (time | usubjid), 
  data = gfr_c
)
```

### Extracting Results

Once you fit the model, you then need to use linear combinations to calculate each desired result. We have written a simple function `get_slope()` which is essentially a wrapper for `multcomp::glht()` but outputs results as a `tibble` for easier export. The main laborious thing about using `multcomp::glht()` is that is requires manual specification of a contrast vector so it knows which coefficients you want to use. Luckily, if you run the model in the exact same way as above with the equivalently coded variables, you should not have to edit any of the code provided. We have also added notes to specify which coefficients are being used to generate each of the results.

``` r
# Source function to extract slope results
source(glue::glue("{path}/src/get_slope.R"))

# Create list object into which to place model results
slopes <- list()

# Acute slopes
slopes[[1]] <- get_slope(
  .model_obj = fit, .name = "Acute: Placebo", 
  # Coefficients: `time`
  .contrasts = c(0, 1, 0, 0, 0, 0)
)
slopes[[2]] <- get_slope(
  .model_obj = fit, .name = "Acute: SGLT2i",
  # Coefficients: `time` + `trt01pn:time`
  .contrasts = c(0, 1, 0, 0, 1, 0)
)
slopes[[3]] <- get_slope(
  .model_obj = fit, .name = "Acute: SGLT2i - Placebo",
  # Coefficients: `trt01pn:time`
  .contrasts = c(0, 0, 0, 0, 1, 0)
)

# Chronic slopes
slopes[[4]] <- get_slope(
  .model_obj = fit, .name = "Chronic: Placebo",
  # Coefficients: `time` + `spline`
  .contrasts = c(0, 1, 0, 1, 0, 0)
)
slopes[[5]] <- get_slope(
  .model_obj = fit, .name = "Chronic: SGLT2i",
  # Coefficients: `time` + `spline` + `trt01pn:time` + `trt`
  .contrasts = c(0, 0, 1, 1, 1, 1)
)
slopes[[6]] <- get_slope(
  .model_obj = fit, .name = "Chronic: SGLT2i - Placebo",
  # Coefficients: `trt01pn:time` + `trt01pn:spline`
  .contrasts = c(0, 0, 0, 0, 1, 1)
)

# Total slopes
# Define proportion of total slope accounted-for by chronic slope (1095.75 is
# the equivalent of 3 years in days, so we if we subtract the number of days in 
# the acute slope, approximately 21 days or 3 weeks, then we get the proportion 
# accounted-for by the chronic slope)
prop <- (1095.75 - 21) / 1095.75

slopes[[7]] <- get_slope(
  .model_obj = fit, .name = "Total: Placebo",
  # Coefficients: `time` + (`prop` * `spline`)
  .contrasts = c(0, 0, 1, prop, 0, 0)
)
slopes[[8]] <- get_slope(
  .model_obj = fit, .name = "Total: SGLT2i",
  # Coefficients: `time` + (`prop` * `spline`) + `trt01pn:time` + 
  # (`prop` * `trt01pn:spline`)
  .contrasts = c(0, 0, 1, prop, 1, prop)
)
slopes[[9]] <- get_slope(
  .model_obj = fit, .name = "Total: SGLT2i - Placebo",
  # Coefficients: `trt01pn:time` + (`prop` * `trt01pn:spline`)
  .contrasts = c(0, 0, 0, 0, 1, prop)
)

# Combine results 
combined <- slopes |> 
  bind_rows()
  
# Print results
print(combined)
#> # A tibble: 9 × 8
#>   name                      estimate     lci     uci result                        se t_value p_value
#>   <chr>                        <dbl>   <dbl>   <dbl> <chr>                      <dbl>   <dbl>   <dbl>
#> 1 Acute: Placebo              10.6     3.53   17.7   10.61 (3.53 to 17.69)     3.61      2.94  0.0033
#> 2 Acute: SGLT2i              -66.2   -73.6   -58.9   -66.24 (-73.61 to -58.87) 3.76    -17.6   0     
#> 3 Acute: SGLT2i - Placebo    -76.9   -87.1   -66.6   -76.86 (-87.07 to -66.64) 5.21    -14.7   0     
#> 4 Chronic: Placebo            -3.60   -3.76   -3.45  -3.60 (-3.76 to -3.45)    0.0805  -44.8   0     
#> 5 Chronic: SGLT2i             -3.69  -10.6     3.20  -3.69 (-10.57 to 3.20)    3.51     -1.05  0.294 
#> 6 Chronic: SGLT2i - Placebo    2.08    1.86    2.31  2.08 (1.86 to 2.31)       0.115    18.1   0     
#> 7 Total: Placebo              -5.49  -12.3     1.29  -5.49 (-12.28 to 1.29)    3.46     -1.59  0.112 
#> 8 Total: SGLT2i               -4.93  -11.8     1.95  -4.93 (-11.81 to 1.95)    3.51     -1.40  0.160 
#> 9 Total: SGLT2i - Placebo      0.569   0.321   0.817 0.57 (0.32 to 0.82)       0.127     4.49  0     
```

Here are the results for acute, chronic and total slope. Some of these results above are completely implausible because of the inaccurate nature of the synthetic data, so do not expect your results to look the same. If you would like to know how to run the same analysis for subgroups, remember to consult the reprex file in the [`code`](https://github.com/ra-fletcher/smartc_egfr_slope/tree/main/code) folder.

## Repository Authors

**Niels Jongs, PhD** - [n.jongs@umcg.nl](mailto:n.jongs@umcg.nl?subject=Inquiry) | University Medical Center Groningen, Groningen, Netherlands

**Robert Fletcher, MSc (Oxon)** - [rfletcher@georgeinstitute.org.au](mailto:rfletcher@georgeinstitute.org.au?subject=Inquiry) | The George Institute for Global Health, Sydney, Australia
